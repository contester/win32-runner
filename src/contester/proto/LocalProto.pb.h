// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: contester/proto/LocalProto.proto

#ifndef PROTOBUF_contester_2fproto_2fLocalProto_2eproto__INCLUDED
#define PROTOBUF_contester_2fproto_2fLocalProto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "contester/proto/BlobProto.pb.h"
#include "contester/proto/ExecutionProto.pb.h"
// @@protoc_insertion_point(includes)

namespace contester {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_contester_2fproto_2fLocalProto_2eproto();
void protobuf_AssignDesc_contester_2fproto_2fLocalProto_2eproto();
void protobuf_ShutdownFile_contester_2fproto_2fLocalProto_2eproto();

class LocalEnvironment;
class LocalEnvironment_Variable;
class LoginInformation;
class LocalExecutionParameters;
class LocalExecutionResult;
class LocalExecution;
class OwnerInfo;
class BinaryTypeRequest;
class BinaryTypeResponse;

enum BinaryTypeResponse_Win32BinaryType {
  BinaryTypeResponse_Win32BinaryType_SCS_32BIT_BINARY = 0,
  BinaryTypeResponse_Win32BinaryType_SCS_DOS_BINARY = 1,
  BinaryTypeResponse_Win32BinaryType_SCS_WOW_BINARY = 2,
  BinaryTypeResponse_Win32BinaryType_SCS_PIF_BINARY = 3,
  BinaryTypeResponse_Win32BinaryType_SCS_POSIX_BINARY = 4,
  BinaryTypeResponse_Win32BinaryType_SCS_OS216_BINARY = 5,
  BinaryTypeResponse_Win32BinaryType_SCS_64BIT_BINARY = 6
};
bool BinaryTypeResponse_Win32BinaryType_IsValid(int value);
const BinaryTypeResponse_Win32BinaryType BinaryTypeResponse_Win32BinaryType_Win32BinaryType_MIN = BinaryTypeResponse_Win32BinaryType_SCS_32BIT_BINARY;
const BinaryTypeResponse_Win32BinaryType BinaryTypeResponse_Win32BinaryType_Win32BinaryType_MAX = BinaryTypeResponse_Win32BinaryType_SCS_64BIT_BINARY;
const int BinaryTypeResponse_Win32BinaryType_Win32BinaryType_ARRAYSIZE = BinaryTypeResponse_Win32BinaryType_Win32BinaryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BinaryTypeResponse_Win32BinaryType_descriptor();
inline const ::std::string& BinaryTypeResponse_Win32BinaryType_Name(BinaryTypeResponse_Win32BinaryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BinaryTypeResponse_Win32BinaryType_descriptor(), value);
}
inline bool BinaryTypeResponse_Win32BinaryType_Parse(
    const ::std::string& name, BinaryTypeResponse_Win32BinaryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BinaryTypeResponse_Win32BinaryType>(
    BinaryTypeResponse_Win32BinaryType_descriptor(), name, value);
}
// ===================================================================

class LocalEnvironment_Variable : public ::google::protobuf::Message {
 public:
  LocalEnvironment_Variable();
  virtual ~LocalEnvironment_Variable();
  
  LocalEnvironment_Variable(const LocalEnvironment_Variable& from);
  
  inline LocalEnvironment_Variable& operator=(const LocalEnvironment_Variable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalEnvironment_Variable& default_instance();
  
  void Swap(LocalEnvironment_Variable* other);
  
  // implements Message ----------------------------------------------
  
  LocalEnvironment_Variable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalEnvironment_Variable& from);
  void MergeFrom(const LocalEnvironment_Variable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // optional bool expand = 3;
  inline bool has_expand() const;
  inline void clear_expand();
  static const int kExpandFieldNumber = 3;
  inline bool expand() const;
  inline void set_expand(bool value);
  
  // @@protoc_insertion_point(class_scope:contester.proto.LocalEnvironment.Variable)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_expand();
  inline void clear_has_expand();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* value_;
  bool expand_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_AssignDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_ShutdownFile_contester_2fproto_2fLocalProto_2eproto();
  
  void InitAsDefaultInstance();
  static LocalEnvironment_Variable* default_instance_;
};
// -------------------------------------------------------------------

class LocalEnvironment : public ::google::protobuf::Message {
 public:
  LocalEnvironment();
  virtual ~LocalEnvironment();
  
  LocalEnvironment(const LocalEnvironment& from);
  
  inline LocalEnvironment& operator=(const LocalEnvironment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalEnvironment& default_instance();
  
  void Swap(LocalEnvironment* other);
  
  // implements Message ----------------------------------------------
  
  LocalEnvironment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalEnvironment& from);
  void MergeFrom(const LocalEnvironment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LocalEnvironment_Variable Variable;
  
  // accessors -------------------------------------------------------
  
  // optional bool empty = 1;
  inline bool has_empty() const;
  inline void clear_empty();
  static const int kEmptyFieldNumber = 1;
  inline bool empty() const;
  inline void set_empty(bool value);
  
  // repeated .contester.proto.LocalEnvironment.Variable variable = 2;
  inline int variable_size() const;
  inline void clear_variable();
  static const int kVariableFieldNumber = 2;
  inline const ::contester::proto::LocalEnvironment_Variable& variable(int index) const;
  inline ::contester::proto::LocalEnvironment_Variable* mutable_variable(int index);
  inline ::contester::proto::LocalEnvironment_Variable* add_variable();
  inline const ::google::protobuf::RepeatedPtrField< ::contester::proto::LocalEnvironment_Variable >&
      variable() const;
  inline ::google::protobuf::RepeatedPtrField< ::contester::proto::LocalEnvironment_Variable >*
      mutable_variable();
  
  // @@protoc_insertion_point(class_scope:contester.proto.LocalEnvironment)
 private:
  inline void set_has_empty();
  inline void clear_has_empty();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::contester::proto::LocalEnvironment_Variable > variable_;
  bool empty_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_AssignDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_ShutdownFile_contester_2fproto_2fLocalProto_2eproto();
  
  void InitAsDefaultInstance();
  static LocalEnvironment* default_instance_;
};
// -------------------------------------------------------------------

class LoginInformation : public ::google::protobuf::Message {
 public:
  LoginInformation();
  virtual ~LoginInformation();
  
  LoginInformation(const LoginInformation& from);
  
  inline LoginInformation& operator=(const LoginInformation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginInformation& default_instance();
  
  void Swap(LoginInformation* other);
  
  // implements Message ----------------------------------------------
  
  LoginInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginInformation& from);
  void MergeFrom(const LoginInformation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional string domain = 3;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 3;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // optional uint32 uid = 4;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 4;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:contester.proto.LoginInformation)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_uid();
  inline void clear_has_uid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::std::string* password_;
  ::std::string* domain_;
  ::google::protobuf::uint32 uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_AssignDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_ShutdownFile_contester_2fproto_2fLocalProto_2eproto();
  
  void InitAsDefaultInstance();
  static LoginInformation* default_instance_;
};
// -------------------------------------------------------------------

class LocalExecutionParameters : public ::google::protobuf::Message {
 public:
  LocalExecutionParameters();
  virtual ~LocalExecutionParameters();
  
  LocalExecutionParameters(const LocalExecutionParameters& from);
  
  inline LocalExecutionParameters& operator=(const LocalExecutionParameters& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalExecutionParameters& default_instance();
  
  void Swap(LocalExecutionParameters* other);
  
  // implements Message ----------------------------------------------
  
  LocalExecutionParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalExecutionParameters& from);
  void MergeFrom(const LocalExecutionParameters& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string application_name = 1;
  inline bool has_application_name() const;
  inline void clear_application_name();
  static const int kApplicationNameFieldNumber = 1;
  inline const ::std::string& application_name() const;
  inline void set_application_name(const ::std::string& value);
  inline void set_application_name(const char* value);
  inline void set_application_name(const char* value, size_t size);
  inline ::std::string* mutable_application_name();
  inline ::std::string* release_application_name();
  
  // optional string command_line = 2;
  inline bool has_command_line() const;
  inline void clear_command_line();
  static const int kCommandLineFieldNumber = 2;
  inline const ::std::string& command_line() const;
  inline void set_command_line(const ::std::string& value);
  inline void set_command_line(const char* value);
  inline void set_command_line(const char* value, size_t size);
  inline ::std::string* mutable_command_line();
  inline ::std::string* release_command_line();
  
  // optional string current_directory = 3;
  inline bool has_current_directory() const;
  inline void clear_current_directory();
  static const int kCurrentDirectoryFieldNumber = 3;
  inline const ::std::string& current_directory() const;
  inline void set_current_directory(const ::std::string& value);
  inline void set_current_directory(const char* value);
  inline void set_current_directory(const char* value, size_t size);
  inline ::std::string* mutable_current_directory();
  inline ::std::string* release_current_directory();
  
  // optional uint64 time_limit_micros = 4;
  inline bool has_time_limit_micros() const;
  inline void clear_time_limit_micros();
  static const int kTimeLimitMicrosFieldNumber = 4;
  inline ::google::protobuf::uint64 time_limit_micros() const;
  inline void set_time_limit_micros(::google::protobuf::uint64 value);
  
  // optional uint64 memory_limit = 5;
  inline bool has_memory_limit() const;
  inline void clear_memory_limit();
  static const int kMemoryLimitFieldNumber = 5;
  inline ::google::protobuf::uint64 memory_limit() const;
  inline void set_memory_limit(::google::protobuf::uint64 value);
  
  // optional bool check_idleness = 6;
  inline bool has_check_idleness() const;
  inline void clear_check_idleness();
  static const int kCheckIdlenessFieldNumber = 6;
  inline bool check_idleness() const;
  inline void set_check_idleness(bool value);
  
  // optional .contester.proto.LocalEnvironment environment = 7;
  inline bool has_environment() const;
  inline void clear_environment();
  static const int kEnvironmentFieldNumber = 7;
  inline const ::contester::proto::LocalEnvironment& environment() const;
  inline ::contester::proto::LocalEnvironment* mutable_environment();
  inline ::contester::proto::LocalEnvironment* release_environment();
  
  // optional bool restrict_ui = 8;
  inline bool has_restrict_ui() const;
  inline void clear_restrict_ui();
  static const int kRestrictUiFieldNumber = 8;
  inline bool restrict_ui() const;
  inline void set_restrict_ui(bool value);
  
  // optional bool no_job = 9;
  inline bool has_no_job() const;
  inline void clear_no_job();
  static const int kNoJobFieldNumber = 9;
  inline bool no_job() const;
  inline void set_no_job(bool value);
  
  // optional uint32 process_limit = 10;
  inline bool has_process_limit() const;
  inline void clear_process_limit();
  static const int kProcessLimitFieldNumber = 10;
  inline ::google::protobuf::uint32 process_limit() const;
  inline void set_process_limit(::google::protobuf::uint32 value);
  
  // optional uint64 time_limit_hard_micros = 15;
  inline bool has_time_limit_hard_micros() const;
  inline void clear_time_limit_hard_micros();
  static const int kTimeLimitHardMicrosFieldNumber = 15;
  inline ::google::protobuf::uint64 time_limit_hard_micros() const;
  inline void set_time_limit_hard_micros(::google::protobuf::uint64 value);
  
  // optional .contester.proto.LoginInformation login_information = 11;
  inline bool has_login_information() const;
  inline void clear_login_information();
  static const int kLoginInformationFieldNumber = 11;
  inline const ::contester::proto::LoginInformation& login_information() const;
  inline ::contester::proto::LoginInformation* mutable_login_information();
  inline ::contester::proto::LoginInformation* release_login_information();
  
  // optional .contester.proto.RedirectParameters std_in = 12;
  inline bool has_std_in() const;
  inline void clear_std_in();
  static const int kStdInFieldNumber = 12;
  inline const ::contester::proto::RedirectParameters& std_in() const;
  inline ::contester::proto::RedirectParameters* mutable_std_in();
  inline ::contester::proto::RedirectParameters* release_std_in();
  
  // optional .contester.proto.RedirectParameters std_out = 13;
  inline bool has_std_out() const;
  inline void clear_std_out();
  static const int kStdOutFieldNumber = 13;
  inline const ::contester::proto::RedirectParameters& std_out() const;
  inline ::contester::proto::RedirectParameters* mutable_std_out();
  inline ::contester::proto::RedirectParameters* release_std_out();
  
  // optional .contester.proto.RedirectParameters std_err = 14;
  inline bool has_std_err() const;
  inline void clear_std_err();
  static const int kStdErrFieldNumber = 14;
  inline const ::contester::proto::RedirectParameters& std_err() const;
  inline ::contester::proto::RedirectParameters* mutable_std_err();
  inline ::contester::proto::RedirectParameters* release_std_err();
  
  // repeated string command_line_parameters = 16;
  inline int command_line_parameters_size() const;
  inline void clear_command_line_parameters();
  static const int kCommandLineParametersFieldNumber = 16;
  inline const ::std::string& command_line_parameters(int index) const;
  inline ::std::string* mutable_command_line_parameters(int index);
  inline void set_command_line_parameters(int index, const ::std::string& value);
  inline void set_command_line_parameters(int index, const char* value);
  inline void set_command_line_parameters(int index, const char* value, size_t size);
  inline ::std::string* add_command_line_parameters();
  inline void add_command_line_parameters(const ::std::string& value);
  inline void add_command_line_parameters(const char* value);
  inline void add_command_line_parameters(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& command_line_parameters() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_command_line_parameters();
  
  // @@protoc_insertion_point(class_scope:contester.proto.LocalExecutionParameters)
 private:
  inline void set_has_application_name();
  inline void clear_has_application_name();
  inline void set_has_command_line();
  inline void clear_has_command_line();
  inline void set_has_current_directory();
  inline void clear_has_current_directory();
  inline void set_has_time_limit_micros();
  inline void clear_has_time_limit_micros();
  inline void set_has_memory_limit();
  inline void clear_has_memory_limit();
  inline void set_has_check_idleness();
  inline void clear_has_check_idleness();
  inline void set_has_environment();
  inline void clear_has_environment();
  inline void set_has_restrict_ui();
  inline void clear_has_restrict_ui();
  inline void set_has_no_job();
  inline void clear_has_no_job();
  inline void set_has_process_limit();
  inline void clear_has_process_limit();
  inline void set_has_time_limit_hard_micros();
  inline void clear_has_time_limit_hard_micros();
  inline void set_has_login_information();
  inline void clear_has_login_information();
  inline void set_has_std_in();
  inline void clear_has_std_in();
  inline void set_has_std_out();
  inline void clear_has_std_out();
  inline void set_has_std_err();
  inline void clear_has_std_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* application_name_;
  ::std::string* command_line_;
  ::std::string* current_directory_;
  ::google::protobuf::uint64 time_limit_micros_;
  ::google::protobuf::uint64 memory_limit_;
  ::contester::proto::LocalEnvironment* environment_;
  bool check_idleness_;
  bool restrict_ui_;
  bool no_job_;
  ::google::protobuf::uint32 process_limit_;
  ::google::protobuf::uint64 time_limit_hard_micros_;
  ::contester::proto::LoginInformation* login_information_;
  ::contester::proto::RedirectParameters* std_in_;
  ::contester::proto::RedirectParameters* std_out_;
  ::contester::proto::RedirectParameters* std_err_;
  ::google::protobuf::RepeatedPtrField< ::std::string> command_line_parameters_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_AssignDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_ShutdownFile_contester_2fproto_2fLocalProto_2eproto();
  
  void InitAsDefaultInstance();
  static LocalExecutionParameters* default_instance_;
};
// -------------------------------------------------------------------

class LocalExecutionResult : public ::google::protobuf::Message {
 public:
  LocalExecutionResult();
  virtual ~LocalExecutionResult();
  
  LocalExecutionResult(const LocalExecutionResult& from);
  
  inline LocalExecutionResult& operator=(const LocalExecutionResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalExecutionResult& default_instance();
  
  void Swap(LocalExecutionResult* other);
  
  // implements Message ----------------------------------------------
  
  LocalExecutionResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalExecutionResult& from);
  void MergeFrom(const LocalExecutionResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .contester.proto.ExecutionResultFlags flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline const ::contester::proto::ExecutionResultFlags& flags() const;
  inline ::contester::proto::ExecutionResultFlags* mutable_flags();
  inline ::contester::proto::ExecutionResultFlags* release_flags();
  
  // optional .contester.proto.ExecutionResultTime time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::contester::proto::ExecutionResultTime& time() const;
  inline ::contester::proto::ExecutionResultTime* mutable_time();
  inline ::contester::proto::ExecutionResultTime* release_time();
  
  // optional uint64 memory = 3;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 3;
  inline ::google::protobuf::uint64 memory() const;
  inline void set_memory(::google::protobuf::uint64 value);
  
  // optional uint32 return_code = 4;
  inline bool has_return_code() const;
  inline void clear_return_code();
  static const int kReturnCodeFieldNumber = 4;
  inline ::google::protobuf::uint32 return_code() const;
  inline void set_return_code(::google::protobuf::uint32 value);
  
  // optional .contester.proto.Blob std_out = 5;
  inline bool has_std_out() const;
  inline void clear_std_out();
  static const int kStdOutFieldNumber = 5;
  inline const ::contester::proto::Blob& std_out() const;
  inline ::contester::proto::Blob* mutable_std_out();
  inline ::contester::proto::Blob* release_std_out();
  
  // optional .contester.proto.Blob std_err = 6;
  inline bool has_std_err() const;
  inline void clear_std_err();
  static const int kStdErrFieldNumber = 6;
  inline const ::contester::proto::Blob& std_err() const;
  inline ::contester::proto::Blob* mutable_std_err();
  inline ::contester::proto::Blob* release_std_err();
  
  // optional uint64 total_processes = 7;
  inline bool has_total_processes() const;
  inline void clear_total_processes();
  static const int kTotalProcessesFieldNumber = 7;
  inline ::google::protobuf::uint64 total_processes() const;
  inline void set_total_processes(::google::protobuf::uint64 value);
  
  // optional int32 kill_signal = 8;
  inline bool has_kill_signal() const;
  inline void clear_kill_signal();
  static const int kKillSignalFieldNumber = 8;
  inline ::google::protobuf::int32 kill_signal() const;
  inline void set_kill_signal(::google::protobuf::int32 value);
  
  // optional int32 stop_signal = 9;
  inline bool has_stop_signal() const;
  inline void clear_stop_signal();
  static const int kStopSignalFieldNumber = 9;
  inline ::google::protobuf::int32 stop_signal() const;
  inline void set_stop_signal(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:contester.proto.LocalExecutionResult)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_return_code();
  inline void clear_has_return_code();
  inline void set_has_std_out();
  inline void clear_has_std_out();
  inline void set_has_std_err();
  inline void clear_has_std_err();
  inline void set_has_total_processes();
  inline void clear_has_total_processes();
  inline void set_has_kill_signal();
  inline void clear_has_kill_signal();
  inline void set_has_stop_signal();
  inline void clear_has_stop_signal();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::contester::proto::ExecutionResultFlags* flags_;
  ::contester::proto::ExecutionResultTime* time_;
  ::google::protobuf::uint64 memory_;
  ::contester::proto::Blob* std_out_;
  ::contester::proto::Blob* std_err_;
  ::google::protobuf::uint32 return_code_;
  ::google::protobuf::int32 kill_signal_;
  ::google::protobuf::uint64 total_processes_;
  ::google::protobuf::int32 stop_signal_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_AssignDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_ShutdownFile_contester_2fproto_2fLocalProto_2eproto();
  
  void InitAsDefaultInstance();
  static LocalExecutionResult* default_instance_;
};
// -------------------------------------------------------------------

class LocalExecution : public ::google::protobuf::Message {
 public:
  LocalExecution();
  virtual ~LocalExecution();
  
  LocalExecution(const LocalExecution& from);
  
  inline LocalExecution& operator=(const LocalExecution& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalExecution& default_instance();
  
  void Swap(LocalExecution* other);
  
  // implements Message ----------------------------------------------
  
  LocalExecution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalExecution& from);
  void MergeFrom(const LocalExecution& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .contester.proto.LocalExecutionParameters parameters = 1;
  inline bool has_parameters() const;
  inline void clear_parameters();
  static const int kParametersFieldNumber = 1;
  inline const ::contester::proto::LocalExecutionParameters& parameters() const;
  inline ::contester::proto::LocalExecutionParameters* mutable_parameters();
  inline ::contester::proto::LocalExecutionParameters* release_parameters();
  
  // optional .contester.proto.LocalExecutionResult result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::contester::proto::LocalExecutionResult& result() const;
  inline ::contester::proto::LocalExecutionResult* mutable_result();
  inline ::contester::proto::LocalExecutionResult* release_result();
  
  // @@protoc_insertion_point(class_scope:contester.proto.LocalExecution)
 private:
  inline void set_has_parameters();
  inline void clear_has_parameters();
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::contester::proto::LocalExecutionParameters* parameters_;
  ::contester::proto::LocalExecutionResult* result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_AssignDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_ShutdownFile_contester_2fproto_2fLocalProto_2eproto();
  
  void InitAsDefaultInstance();
  static LocalExecution* default_instance_;
};
// -------------------------------------------------------------------

class OwnerInfo : public ::google::protobuf::Message {
 public:
  OwnerInfo();
  virtual ~OwnerInfo();
  
  OwnerInfo(const OwnerInfo& from);
  
  inline OwnerInfo& operator=(const OwnerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OwnerInfo& default_instance();
  
  void Swap(OwnerInfo* other);
  
  // implements Message ----------------------------------------------
  
  OwnerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OwnerInfo& from);
  void MergeFrom(const OwnerInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);
  
  // repeated string pathname = 2;
  inline int pathname_size() const;
  inline void clear_pathname();
  static const int kPathnameFieldNumber = 2;
  inline const ::std::string& pathname(int index) const;
  inline ::std::string* mutable_pathname(int index);
  inline void set_pathname(int index, const ::std::string& value);
  inline void set_pathname(int index, const char* value);
  inline void set_pathname(int index, const char* value, size_t size);
  inline ::std::string* add_pathname();
  inline void add_pathname(const ::std::string& value);
  inline void add_pathname(const char* value);
  inline void add_pathname(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pathname() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pathname();
  
  // @@protoc_insertion_point(class_scope:contester.proto.OwnerInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> pathname_;
  ::google::protobuf::uint32 uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_AssignDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_ShutdownFile_contester_2fproto_2fLocalProto_2eproto();
  
  void InitAsDefaultInstance();
  static OwnerInfo* default_instance_;
};
// -------------------------------------------------------------------

class BinaryTypeRequest : public ::google::protobuf::Message {
 public:
  BinaryTypeRequest();
  virtual ~BinaryTypeRequest();
  
  BinaryTypeRequest(const BinaryTypeRequest& from);
  
  inline BinaryTypeRequest& operator=(const BinaryTypeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinaryTypeRequest& default_instance();
  
  void Swap(BinaryTypeRequest* other);
  
  // implements Message ----------------------------------------------
  
  BinaryTypeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BinaryTypeRequest& from);
  void MergeFrom(const BinaryTypeRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string pathname = 1;
  inline bool has_pathname() const;
  inline void clear_pathname();
  static const int kPathnameFieldNumber = 1;
  inline const ::std::string& pathname() const;
  inline void set_pathname(const ::std::string& value);
  inline void set_pathname(const char* value);
  inline void set_pathname(const char* value, size_t size);
  inline ::std::string* mutable_pathname();
  inline ::std::string* release_pathname();
  
  // @@protoc_insertion_point(class_scope:contester.proto.BinaryTypeRequest)
 private:
  inline void set_has_pathname();
  inline void clear_has_pathname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* pathname_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_AssignDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_ShutdownFile_contester_2fproto_2fLocalProto_2eproto();
  
  void InitAsDefaultInstance();
  static BinaryTypeRequest* default_instance_;
};
// -------------------------------------------------------------------

class BinaryTypeResponse : public ::google::protobuf::Message {
 public:
  BinaryTypeResponse();
  virtual ~BinaryTypeResponse();
  
  BinaryTypeResponse(const BinaryTypeResponse& from);
  
  inline BinaryTypeResponse& operator=(const BinaryTypeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinaryTypeResponse& default_instance();
  
  void Swap(BinaryTypeResponse* other);
  
  // implements Message ----------------------------------------------
  
  BinaryTypeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BinaryTypeResponse& from);
  void MergeFrom(const BinaryTypeResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef BinaryTypeResponse_Win32BinaryType Win32BinaryType;
  static const Win32BinaryType SCS_32BIT_BINARY = BinaryTypeResponse_Win32BinaryType_SCS_32BIT_BINARY;
  static const Win32BinaryType SCS_DOS_BINARY = BinaryTypeResponse_Win32BinaryType_SCS_DOS_BINARY;
  static const Win32BinaryType SCS_WOW_BINARY = BinaryTypeResponse_Win32BinaryType_SCS_WOW_BINARY;
  static const Win32BinaryType SCS_PIF_BINARY = BinaryTypeResponse_Win32BinaryType_SCS_PIF_BINARY;
  static const Win32BinaryType SCS_POSIX_BINARY = BinaryTypeResponse_Win32BinaryType_SCS_POSIX_BINARY;
  static const Win32BinaryType SCS_OS216_BINARY = BinaryTypeResponse_Win32BinaryType_SCS_OS216_BINARY;
  static const Win32BinaryType SCS_64BIT_BINARY = BinaryTypeResponse_Win32BinaryType_SCS_64BIT_BINARY;
  static inline bool Win32BinaryType_IsValid(int value) {
    return BinaryTypeResponse_Win32BinaryType_IsValid(value);
  }
  static const Win32BinaryType Win32BinaryType_MIN =
    BinaryTypeResponse_Win32BinaryType_Win32BinaryType_MIN;
  static const Win32BinaryType Win32BinaryType_MAX =
    BinaryTypeResponse_Win32BinaryType_Win32BinaryType_MAX;
  static const int Win32BinaryType_ARRAYSIZE =
    BinaryTypeResponse_Win32BinaryType_Win32BinaryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Win32BinaryType_descriptor() {
    return BinaryTypeResponse_Win32BinaryType_descriptor();
  }
  static inline const ::std::string& Win32BinaryType_Name(Win32BinaryType value) {
    return BinaryTypeResponse_Win32BinaryType_Name(value);
  }
  static inline bool Win32BinaryType_Parse(const ::std::string& name,
      Win32BinaryType* value) {
    return BinaryTypeResponse_Win32BinaryType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional bool failure = 1;
  inline bool has_failure() const;
  inline void clear_failure();
  static const int kFailureFieldNumber = 1;
  inline bool failure() const;
  inline void set_failure(bool value);
  
  // optional .contester.proto.BinaryTypeResponse.Win32BinaryType result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::contester::proto::BinaryTypeResponse_Win32BinaryType result() const;
  inline void set_result(::contester::proto::BinaryTypeResponse_Win32BinaryType value);
  
  // @@protoc_insertion_point(class_scope:contester.proto.BinaryTypeResponse)
 private:
  inline void set_has_failure();
  inline void clear_has_failure();
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool failure_;
  int result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_AssignDesc_contester_2fproto_2fLocalProto_2eproto();
  friend void protobuf_ShutdownFile_contester_2fproto_2fLocalProto_2eproto();
  
  void InitAsDefaultInstance();
  static BinaryTypeResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// LocalEnvironment_Variable

// required string name = 1;
inline bool LocalEnvironment_Variable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalEnvironment_Variable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalEnvironment_Variable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalEnvironment_Variable::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LocalEnvironment_Variable::name() const {
  return *name_;
}
inline void LocalEnvironment_Variable::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LocalEnvironment_Variable::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LocalEnvironment_Variable::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalEnvironment_Variable::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LocalEnvironment_Variable::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string value = 2;
inline bool LocalEnvironment_Variable::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalEnvironment_Variable::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalEnvironment_Variable::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalEnvironment_Variable::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& LocalEnvironment_Variable::value() const {
  return *value_;
}
inline void LocalEnvironment_Variable::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void LocalEnvironment_Variable::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void LocalEnvironment_Variable::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalEnvironment_Variable::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* LocalEnvironment_Variable::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool expand = 3;
inline bool LocalEnvironment_Variable::has_expand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalEnvironment_Variable::set_has_expand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalEnvironment_Variable::clear_has_expand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalEnvironment_Variable::clear_expand() {
  expand_ = false;
  clear_has_expand();
}
inline bool LocalEnvironment_Variable::expand() const {
  return expand_;
}
inline void LocalEnvironment_Variable::set_expand(bool value) {
  set_has_expand();
  expand_ = value;
}

// -------------------------------------------------------------------

// LocalEnvironment

// optional bool empty = 1;
inline bool LocalEnvironment::has_empty() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalEnvironment::set_has_empty() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalEnvironment::clear_has_empty() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalEnvironment::clear_empty() {
  empty_ = false;
  clear_has_empty();
}
inline bool LocalEnvironment::empty() const {
  return empty_;
}
inline void LocalEnvironment::set_empty(bool value) {
  set_has_empty();
  empty_ = value;
}

// repeated .contester.proto.LocalEnvironment.Variable variable = 2;
inline int LocalEnvironment::variable_size() const {
  return variable_.size();
}
inline void LocalEnvironment::clear_variable() {
  variable_.Clear();
}
inline const ::contester::proto::LocalEnvironment_Variable& LocalEnvironment::variable(int index) const {
  return variable_.Get(index);
}
inline ::contester::proto::LocalEnvironment_Variable* LocalEnvironment::mutable_variable(int index) {
  return variable_.Mutable(index);
}
inline ::contester::proto::LocalEnvironment_Variable* LocalEnvironment::add_variable() {
  return variable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::contester::proto::LocalEnvironment_Variable >&
LocalEnvironment::variable() const {
  return variable_;
}
inline ::google::protobuf::RepeatedPtrField< ::contester::proto::LocalEnvironment_Variable >*
LocalEnvironment::mutable_variable() {
  return &variable_;
}

// -------------------------------------------------------------------

// LoginInformation

// optional string username = 1;
inline bool LoginInformation::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginInformation::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginInformation::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginInformation::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& LoginInformation::username() const {
  return *username_;
}
inline void LoginInformation::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginInformation::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginInformation::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInformation::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* LoginInformation::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string password = 2;
inline bool LoginInformation::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginInformation::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginInformation::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginInformation::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginInformation::password() const {
  return *password_;
}
inline void LoginInformation::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginInformation::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginInformation::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInformation::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginInformation::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string domain = 3;
inline bool LoginInformation::has_domain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginInformation::set_has_domain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginInformation::clear_has_domain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginInformation::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& LoginInformation::domain() const {
  return *domain_;
}
inline void LoginInformation::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void LoginInformation::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void LoginInformation::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInformation::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* LoginInformation::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 uid = 4;
inline bool LoginInformation::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginInformation::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginInformation::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginInformation::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 LoginInformation::uid() const {
  return uid_;
}
inline void LoginInformation::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// LocalExecutionParameters

// optional string application_name = 1;
inline bool LocalExecutionParameters::has_application_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalExecutionParameters::set_has_application_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalExecutionParameters::clear_has_application_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalExecutionParameters::clear_application_name() {
  if (application_name_ != &::google::protobuf::internal::kEmptyString) {
    application_name_->clear();
  }
  clear_has_application_name();
}
inline const ::std::string& LocalExecutionParameters::application_name() const {
  return *application_name_;
}
inline void LocalExecutionParameters::set_application_name(const ::std::string& value) {
  set_has_application_name();
  if (application_name_ == &::google::protobuf::internal::kEmptyString) {
    application_name_ = new ::std::string;
  }
  application_name_->assign(value);
}
inline void LocalExecutionParameters::set_application_name(const char* value) {
  set_has_application_name();
  if (application_name_ == &::google::protobuf::internal::kEmptyString) {
    application_name_ = new ::std::string;
  }
  application_name_->assign(value);
}
inline void LocalExecutionParameters::set_application_name(const char* value, size_t size) {
  set_has_application_name();
  if (application_name_ == &::google::protobuf::internal::kEmptyString) {
    application_name_ = new ::std::string;
  }
  application_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalExecutionParameters::mutable_application_name() {
  set_has_application_name();
  if (application_name_ == &::google::protobuf::internal::kEmptyString) {
    application_name_ = new ::std::string;
  }
  return application_name_;
}
inline ::std::string* LocalExecutionParameters::release_application_name() {
  clear_has_application_name();
  if (application_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = application_name_;
    application_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string command_line = 2;
inline bool LocalExecutionParameters::has_command_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalExecutionParameters::set_has_command_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalExecutionParameters::clear_has_command_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalExecutionParameters::clear_command_line() {
  if (command_line_ != &::google::protobuf::internal::kEmptyString) {
    command_line_->clear();
  }
  clear_has_command_line();
}
inline const ::std::string& LocalExecutionParameters::command_line() const {
  return *command_line_;
}
inline void LocalExecutionParameters::set_command_line(const ::std::string& value) {
  set_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    command_line_ = new ::std::string;
  }
  command_line_->assign(value);
}
inline void LocalExecutionParameters::set_command_line(const char* value) {
  set_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    command_line_ = new ::std::string;
  }
  command_line_->assign(value);
}
inline void LocalExecutionParameters::set_command_line(const char* value, size_t size) {
  set_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    command_line_ = new ::std::string;
  }
  command_line_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalExecutionParameters::mutable_command_line() {
  set_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    command_line_ = new ::std::string;
  }
  return command_line_;
}
inline ::std::string* LocalExecutionParameters::release_command_line() {
  clear_has_command_line();
  if (command_line_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = command_line_;
    command_line_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string current_directory = 3;
inline bool LocalExecutionParameters::has_current_directory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalExecutionParameters::set_has_current_directory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalExecutionParameters::clear_has_current_directory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalExecutionParameters::clear_current_directory() {
  if (current_directory_ != &::google::protobuf::internal::kEmptyString) {
    current_directory_->clear();
  }
  clear_has_current_directory();
}
inline const ::std::string& LocalExecutionParameters::current_directory() const {
  return *current_directory_;
}
inline void LocalExecutionParameters::set_current_directory(const ::std::string& value) {
  set_has_current_directory();
  if (current_directory_ == &::google::protobuf::internal::kEmptyString) {
    current_directory_ = new ::std::string;
  }
  current_directory_->assign(value);
}
inline void LocalExecutionParameters::set_current_directory(const char* value) {
  set_has_current_directory();
  if (current_directory_ == &::google::protobuf::internal::kEmptyString) {
    current_directory_ = new ::std::string;
  }
  current_directory_->assign(value);
}
inline void LocalExecutionParameters::set_current_directory(const char* value, size_t size) {
  set_has_current_directory();
  if (current_directory_ == &::google::protobuf::internal::kEmptyString) {
    current_directory_ = new ::std::string;
  }
  current_directory_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalExecutionParameters::mutable_current_directory() {
  set_has_current_directory();
  if (current_directory_ == &::google::protobuf::internal::kEmptyString) {
    current_directory_ = new ::std::string;
  }
  return current_directory_;
}
inline ::std::string* LocalExecutionParameters::release_current_directory() {
  clear_has_current_directory();
  if (current_directory_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = current_directory_;
    current_directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 time_limit_micros = 4;
inline bool LocalExecutionParameters::has_time_limit_micros() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocalExecutionParameters::set_has_time_limit_micros() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocalExecutionParameters::clear_has_time_limit_micros() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocalExecutionParameters::clear_time_limit_micros() {
  time_limit_micros_ = GOOGLE_ULONGLONG(0);
  clear_has_time_limit_micros();
}
inline ::google::protobuf::uint64 LocalExecutionParameters::time_limit_micros() const {
  return time_limit_micros_;
}
inline void LocalExecutionParameters::set_time_limit_micros(::google::protobuf::uint64 value) {
  set_has_time_limit_micros();
  time_limit_micros_ = value;
}

// optional uint64 memory_limit = 5;
inline bool LocalExecutionParameters::has_memory_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocalExecutionParameters::set_has_memory_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocalExecutionParameters::clear_has_memory_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocalExecutionParameters::clear_memory_limit() {
  memory_limit_ = GOOGLE_ULONGLONG(0);
  clear_has_memory_limit();
}
inline ::google::protobuf::uint64 LocalExecutionParameters::memory_limit() const {
  return memory_limit_;
}
inline void LocalExecutionParameters::set_memory_limit(::google::protobuf::uint64 value) {
  set_has_memory_limit();
  memory_limit_ = value;
}

// optional bool check_idleness = 6;
inline bool LocalExecutionParameters::has_check_idleness() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LocalExecutionParameters::set_has_check_idleness() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LocalExecutionParameters::clear_has_check_idleness() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LocalExecutionParameters::clear_check_idleness() {
  check_idleness_ = false;
  clear_has_check_idleness();
}
inline bool LocalExecutionParameters::check_idleness() const {
  return check_idleness_;
}
inline void LocalExecutionParameters::set_check_idleness(bool value) {
  set_has_check_idleness();
  check_idleness_ = value;
}

// optional .contester.proto.LocalEnvironment environment = 7;
inline bool LocalExecutionParameters::has_environment() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LocalExecutionParameters::set_has_environment() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LocalExecutionParameters::clear_has_environment() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LocalExecutionParameters::clear_environment() {
  if (environment_ != NULL) environment_->::contester::proto::LocalEnvironment::Clear();
  clear_has_environment();
}
inline const ::contester::proto::LocalEnvironment& LocalExecutionParameters::environment() const {
  return environment_ != NULL ? *environment_ : *default_instance_->environment_;
}
inline ::contester::proto::LocalEnvironment* LocalExecutionParameters::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) environment_ = new ::contester::proto::LocalEnvironment;
  return environment_;
}
inline ::contester::proto::LocalEnvironment* LocalExecutionParameters::release_environment() {
  clear_has_environment();
  ::contester::proto::LocalEnvironment* temp = environment_;
  environment_ = NULL;
  return temp;
}

// optional bool restrict_ui = 8;
inline bool LocalExecutionParameters::has_restrict_ui() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LocalExecutionParameters::set_has_restrict_ui() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LocalExecutionParameters::clear_has_restrict_ui() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LocalExecutionParameters::clear_restrict_ui() {
  restrict_ui_ = false;
  clear_has_restrict_ui();
}
inline bool LocalExecutionParameters::restrict_ui() const {
  return restrict_ui_;
}
inline void LocalExecutionParameters::set_restrict_ui(bool value) {
  set_has_restrict_ui();
  restrict_ui_ = value;
}

// optional bool no_job = 9;
inline bool LocalExecutionParameters::has_no_job() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LocalExecutionParameters::set_has_no_job() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LocalExecutionParameters::clear_has_no_job() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LocalExecutionParameters::clear_no_job() {
  no_job_ = false;
  clear_has_no_job();
}
inline bool LocalExecutionParameters::no_job() const {
  return no_job_;
}
inline void LocalExecutionParameters::set_no_job(bool value) {
  set_has_no_job();
  no_job_ = value;
}

// optional uint32 process_limit = 10;
inline bool LocalExecutionParameters::has_process_limit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LocalExecutionParameters::set_has_process_limit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LocalExecutionParameters::clear_has_process_limit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LocalExecutionParameters::clear_process_limit() {
  process_limit_ = 0u;
  clear_has_process_limit();
}
inline ::google::protobuf::uint32 LocalExecutionParameters::process_limit() const {
  return process_limit_;
}
inline void LocalExecutionParameters::set_process_limit(::google::protobuf::uint32 value) {
  set_has_process_limit();
  process_limit_ = value;
}

// optional uint64 time_limit_hard_micros = 15;
inline bool LocalExecutionParameters::has_time_limit_hard_micros() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LocalExecutionParameters::set_has_time_limit_hard_micros() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LocalExecutionParameters::clear_has_time_limit_hard_micros() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LocalExecutionParameters::clear_time_limit_hard_micros() {
  time_limit_hard_micros_ = GOOGLE_ULONGLONG(0);
  clear_has_time_limit_hard_micros();
}
inline ::google::protobuf::uint64 LocalExecutionParameters::time_limit_hard_micros() const {
  return time_limit_hard_micros_;
}
inline void LocalExecutionParameters::set_time_limit_hard_micros(::google::protobuf::uint64 value) {
  set_has_time_limit_hard_micros();
  time_limit_hard_micros_ = value;
}

// optional .contester.proto.LoginInformation login_information = 11;
inline bool LocalExecutionParameters::has_login_information() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LocalExecutionParameters::set_has_login_information() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LocalExecutionParameters::clear_has_login_information() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LocalExecutionParameters::clear_login_information() {
  if (login_information_ != NULL) login_information_->::contester::proto::LoginInformation::Clear();
  clear_has_login_information();
}
inline const ::contester::proto::LoginInformation& LocalExecutionParameters::login_information() const {
  return login_information_ != NULL ? *login_information_ : *default_instance_->login_information_;
}
inline ::contester::proto::LoginInformation* LocalExecutionParameters::mutable_login_information() {
  set_has_login_information();
  if (login_information_ == NULL) login_information_ = new ::contester::proto::LoginInformation;
  return login_information_;
}
inline ::contester::proto::LoginInformation* LocalExecutionParameters::release_login_information() {
  clear_has_login_information();
  ::contester::proto::LoginInformation* temp = login_information_;
  login_information_ = NULL;
  return temp;
}

// optional .contester.proto.RedirectParameters std_in = 12;
inline bool LocalExecutionParameters::has_std_in() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LocalExecutionParameters::set_has_std_in() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LocalExecutionParameters::clear_has_std_in() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LocalExecutionParameters::clear_std_in() {
  if (std_in_ != NULL) std_in_->::contester::proto::RedirectParameters::Clear();
  clear_has_std_in();
}
inline const ::contester::proto::RedirectParameters& LocalExecutionParameters::std_in() const {
  return std_in_ != NULL ? *std_in_ : *default_instance_->std_in_;
}
inline ::contester::proto::RedirectParameters* LocalExecutionParameters::mutable_std_in() {
  set_has_std_in();
  if (std_in_ == NULL) std_in_ = new ::contester::proto::RedirectParameters;
  return std_in_;
}
inline ::contester::proto::RedirectParameters* LocalExecutionParameters::release_std_in() {
  clear_has_std_in();
  ::contester::proto::RedirectParameters* temp = std_in_;
  std_in_ = NULL;
  return temp;
}

// optional .contester.proto.RedirectParameters std_out = 13;
inline bool LocalExecutionParameters::has_std_out() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LocalExecutionParameters::set_has_std_out() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LocalExecutionParameters::clear_has_std_out() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LocalExecutionParameters::clear_std_out() {
  if (std_out_ != NULL) std_out_->::contester::proto::RedirectParameters::Clear();
  clear_has_std_out();
}
inline const ::contester::proto::RedirectParameters& LocalExecutionParameters::std_out() const {
  return std_out_ != NULL ? *std_out_ : *default_instance_->std_out_;
}
inline ::contester::proto::RedirectParameters* LocalExecutionParameters::mutable_std_out() {
  set_has_std_out();
  if (std_out_ == NULL) std_out_ = new ::contester::proto::RedirectParameters;
  return std_out_;
}
inline ::contester::proto::RedirectParameters* LocalExecutionParameters::release_std_out() {
  clear_has_std_out();
  ::contester::proto::RedirectParameters* temp = std_out_;
  std_out_ = NULL;
  return temp;
}

// optional .contester.proto.RedirectParameters std_err = 14;
inline bool LocalExecutionParameters::has_std_err() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LocalExecutionParameters::set_has_std_err() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LocalExecutionParameters::clear_has_std_err() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LocalExecutionParameters::clear_std_err() {
  if (std_err_ != NULL) std_err_->::contester::proto::RedirectParameters::Clear();
  clear_has_std_err();
}
inline const ::contester::proto::RedirectParameters& LocalExecutionParameters::std_err() const {
  return std_err_ != NULL ? *std_err_ : *default_instance_->std_err_;
}
inline ::contester::proto::RedirectParameters* LocalExecutionParameters::mutable_std_err() {
  set_has_std_err();
  if (std_err_ == NULL) std_err_ = new ::contester::proto::RedirectParameters;
  return std_err_;
}
inline ::contester::proto::RedirectParameters* LocalExecutionParameters::release_std_err() {
  clear_has_std_err();
  ::contester::proto::RedirectParameters* temp = std_err_;
  std_err_ = NULL;
  return temp;
}

// repeated string command_line_parameters = 16;
inline int LocalExecutionParameters::command_line_parameters_size() const {
  return command_line_parameters_.size();
}
inline void LocalExecutionParameters::clear_command_line_parameters() {
  command_line_parameters_.Clear();
}
inline const ::std::string& LocalExecutionParameters::command_line_parameters(int index) const {
  return command_line_parameters_.Get(index);
}
inline ::std::string* LocalExecutionParameters::mutable_command_line_parameters(int index) {
  return command_line_parameters_.Mutable(index);
}
inline void LocalExecutionParameters::set_command_line_parameters(int index, const ::std::string& value) {
  command_line_parameters_.Mutable(index)->assign(value);
}
inline void LocalExecutionParameters::set_command_line_parameters(int index, const char* value) {
  command_line_parameters_.Mutable(index)->assign(value);
}
inline void LocalExecutionParameters::set_command_line_parameters(int index, const char* value, size_t size) {
  command_line_parameters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalExecutionParameters::add_command_line_parameters() {
  return command_line_parameters_.Add();
}
inline void LocalExecutionParameters::add_command_line_parameters(const ::std::string& value) {
  command_line_parameters_.Add()->assign(value);
}
inline void LocalExecutionParameters::add_command_line_parameters(const char* value) {
  command_line_parameters_.Add()->assign(value);
}
inline void LocalExecutionParameters::add_command_line_parameters(const char* value, size_t size) {
  command_line_parameters_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LocalExecutionParameters::command_line_parameters() const {
  return command_line_parameters_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LocalExecutionParameters::mutable_command_line_parameters() {
  return &command_line_parameters_;
}

// -------------------------------------------------------------------

// LocalExecutionResult

// optional .contester.proto.ExecutionResultFlags flags = 1;
inline bool LocalExecutionResult::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalExecutionResult::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalExecutionResult::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalExecutionResult::clear_flags() {
  if (flags_ != NULL) flags_->::contester::proto::ExecutionResultFlags::Clear();
  clear_has_flags();
}
inline const ::contester::proto::ExecutionResultFlags& LocalExecutionResult::flags() const {
  return flags_ != NULL ? *flags_ : *default_instance_->flags_;
}
inline ::contester::proto::ExecutionResultFlags* LocalExecutionResult::mutable_flags() {
  set_has_flags();
  if (flags_ == NULL) flags_ = new ::contester::proto::ExecutionResultFlags;
  return flags_;
}
inline ::contester::proto::ExecutionResultFlags* LocalExecutionResult::release_flags() {
  clear_has_flags();
  ::contester::proto::ExecutionResultFlags* temp = flags_;
  flags_ = NULL;
  return temp;
}

// optional .contester.proto.ExecutionResultTime time = 2;
inline bool LocalExecutionResult::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalExecutionResult::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalExecutionResult::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalExecutionResult::clear_time() {
  if (time_ != NULL) time_->::contester::proto::ExecutionResultTime::Clear();
  clear_has_time();
}
inline const ::contester::proto::ExecutionResultTime& LocalExecutionResult::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::contester::proto::ExecutionResultTime* LocalExecutionResult::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::contester::proto::ExecutionResultTime;
  return time_;
}
inline ::contester::proto::ExecutionResultTime* LocalExecutionResult::release_time() {
  clear_has_time();
  ::contester::proto::ExecutionResultTime* temp = time_;
  time_ = NULL;
  return temp;
}

// optional uint64 memory = 3;
inline bool LocalExecutionResult::has_memory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalExecutionResult::set_has_memory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalExecutionResult::clear_has_memory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalExecutionResult::clear_memory() {
  memory_ = GOOGLE_ULONGLONG(0);
  clear_has_memory();
}
inline ::google::protobuf::uint64 LocalExecutionResult::memory() const {
  return memory_;
}
inline void LocalExecutionResult::set_memory(::google::protobuf::uint64 value) {
  set_has_memory();
  memory_ = value;
}

// optional uint32 return_code = 4;
inline bool LocalExecutionResult::has_return_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocalExecutionResult::set_has_return_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocalExecutionResult::clear_has_return_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocalExecutionResult::clear_return_code() {
  return_code_ = 0u;
  clear_has_return_code();
}
inline ::google::protobuf::uint32 LocalExecutionResult::return_code() const {
  return return_code_;
}
inline void LocalExecutionResult::set_return_code(::google::protobuf::uint32 value) {
  set_has_return_code();
  return_code_ = value;
}

// optional .contester.proto.Blob std_out = 5;
inline bool LocalExecutionResult::has_std_out() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocalExecutionResult::set_has_std_out() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocalExecutionResult::clear_has_std_out() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocalExecutionResult::clear_std_out() {
  if (std_out_ != NULL) std_out_->::contester::proto::Blob::Clear();
  clear_has_std_out();
}
inline const ::contester::proto::Blob& LocalExecutionResult::std_out() const {
  return std_out_ != NULL ? *std_out_ : *default_instance_->std_out_;
}
inline ::contester::proto::Blob* LocalExecutionResult::mutable_std_out() {
  set_has_std_out();
  if (std_out_ == NULL) std_out_ = new ::contester::proto::Blob;
  return std_out_;
}
inline ::contester::proto::Blob* LocalExecutionResult::release_std_out() {
  clear_has_std_out();
  ::contester::proto::Blob* temp = std_out_;
  std_out_ = NULL;
  return temp;
}

// optional .contester.proto.Blob std_err = 6;
inline bool LocalExecutionResult::has_std_err() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LocalExecutionResult::set_has_std_err() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LocalExecutionResult::clear_has_std_err() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LocalExecutionResult::clear_std_err() {
  if (std_err_ != NULL) std_err_->::contester::proto::Blob::Clear();
  clear_has_std_err();
}
inline const ::contester::proto::Blob& LocalExecutionResult::std_err() const {
  return std_err_ != NULL ? *std_err_ : *default_instance_->std_err_;
}
inline ::contester::proto::Blob* LocalExecutionResult::mutable_std_err() {
  set_has_std_err();
  if (std_err_ == NULL) std_err_ = new ::contester::proto::Blob;
  return std_err_;
}
inline ::contester::proto::Blob* LocalExecutionResult::release_std_err() {
  clear_has_std_err();
  ::contester::proto::Blob* temp = std_err_;
  std_err_ = NULL;
  return temp;
}

// optional uint64 total_processes = 7;
inline bool LocalExecutionResult::has_total_processes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LocalExecutionResult::set_has_total_processes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LocalExecutionResult::clear_has_total_processes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LocalExecutionResult::clear_total_processes() {
  total_processes_ = GOOGLE_ULONGLONG(0);
  clear_has_total_processes();
}
inline ::google::protobuf::uint64 LocalExecutionResult::total_processes() const {
  return total_processes_;
}
inline void LocalExecutionResult::set_total_processes(::google::protobuf::uint64 value) {
  set_has_total_processes();
  total_processes_ = value;
}

// optional int32 kill_signal = 8;
inline bool LocalExecutionResult::has_kill_signal() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LocalExecutionResult::set_has_kill_signal() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LocalExecutionResult::clear_has_kill_signal() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LocalExecutionResult::clear_kill_signal() {
  kill_signal_ = 0;
  clear_has_kill_signal();
}
inline ::google::protobuf::int32 LocalExecutionResult::kill_signal() const {
  return kill_signal_;
}
inline void LocalExecutionResult::set_kill_signal(::google::protobuf::int32 value) {
  set_has_kill_signal();
  kill_signal_ = value;
}

// optional int32 stop_signal = 9;
inline bool LocalExecutionResult::has_stop_signal() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LocalExecutionResult::set_has_stop_signal() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LocalExecutionResult::clear_has_stop_signal() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LocalExecutionResult::clear_stop_signal() {
  stop_signal_ = 0;
  clear_has_stop_signal();
}
inline ::google::protobuf::int32 LocalExecutionResult::stop_signal() const {
  return stop_signal_;
}
inline void LocalExecutionResult::set_stop_signal(::google::protobuf::int32 value) {
  set_has_stop_signal();
  stop_signal_ = value;
}

// -------------------------------------------------------------------

// LocalExecution

// required .contester.proto.LocalExecutionParameters parameters = 1;
inline bool LocalExecution::has_parameters() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalExecution::set_has_parameters() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalExecution::clear_has_parameters() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalExecution::clear_parameters() {
  if (parameters_ != NULL) parameters_->::contester::proto::LocalExecutionParameters::Clear();
  clear_has_parameters();
}
inline const ::contester::proto::LocalExecutionParameters& LocalExecution::parameters() const {
  return parameters_ != NULL ? *parameters_ : *default_instance_->parameters_;
}
inline ::contester::proto::LocalExecutionParameters* LocalExecution::mutable_parameters() {
  set_has_parameters();
  if (parameters_ == NULL) parameters_ = new ::contester::proto::LocalExecutionParameters;
  return parameters_;
}
inline ::contester::proto::LocalExecutionParameters* LocalExecution::release_parameters() {
  clear_has_parameters();
  ::contester::proto::LocalExecutionParameters* temp = parameters_;
  parameters_ = NULL;
  return temp;
}

// optional .contester.proto.LocalExecutionResult result = 2;
inline bool LocalExecution::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalExecution::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalExecution::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalExecution::clear_result() {
  if (result_ != NULL) result_->::contester::proto::LocalExecutionResult::Clear();
  clear_has_result();
}
inline const ::contester::proto::LocalExecutionResult& LocalExecution::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::contester::proto::LocalExecutionResult* LocalExecution::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::contester::proto::LocalExecutionResult;
  return result_;
}
inline ::contester::proto::LocalExecutionResult* LocalExecution::release_result() {
  clear_has_result();
  ::contester::proto::LocalExecutionResult* temp = result_;
  result_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// OwnerInfo

// optional uint32 uid = 1;
inline bool OwnerInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OwnerInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OwnerInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OwnerInfo::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 OwnerInfo::uid() const {
  return uid_;
}
inline void OwnerInfo::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// repeated string pathname = 2;
inline int OwnerInfo::pathname_size() const {
  return pathname_.size();
}
inline void OwnerInfo::clear_pathname() {
  pathname_.Clear();
}
inline const ::std::string& OwnerInfo::pathname(int index) const {
  return pathname_.Get(index);
}
inline ::std::string* OwnerInfo::mutable_pathname(int index) {
  return pathname_.Mutable(index);
}
inline void OwnerInfo::set_pathname(int index, const ::std::string& value) {
  pathname_.Mutable(index)->assign(value);
}
inline void OwnerInfo::set_pathname(int index, const char* value) {
  pathname_.Mutable(index)->assign(value);
}
inline void OwnerInfo::set_pathname(int index, const char* value, size_t size) {
  pathname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OwnerInfo::add_pathname() {
  return pathname_.Add();
}
inline void OwnerInfo::add_pathname(const ::std::string& value) {
  pathname_.Add()->assign(value);
}
inline void OwnerInfo::add_pathname(const char* value) {
  pathname_.Add()->assign(value);
}
inline void OwnerInfo::add_pathname(const char* value, size_t size) {
  pathname_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OwnerInfo::pathname() const {
  return pathname_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OwnerInfo::mutable_pathname() {
  return &pathname_;
}

// -------------------------------------------------------------------

// BinaryTypeRequest

// optional string pathname = 1;
inline bool BinaryTypeRequest::has_pathname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinaryTypeRequest::set_has_pathname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BinaryTypeRequest::clear_has_pathname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BinaryTypeRequest::clear_pathname() {
  if (pathname_ != &::google::protobuf::internal::kEmptyString) {
    pathname_->clear();
  }
  clear_has_pathname();
}
inline const ::std::string& BinaryTypeRequest::pathname() const {
  return *pathname_;
}
inline void BinaryTypeRequest::set_pathname(const ::std::string& value) {
  set_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    pathname_ = new ::std::string;
  }
  pathname_->assign(value);
}
inline void BinaryTypeRequest::set_pathname(const char* value) {
  set_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    pathname_ = new ::std::string;
  }
  pathname_->assign(value);
}
inline void BinaryTypeRequest::set_pathname(const char* value, size_t size) {
  set_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    pathname_ = new ::std::string;
  }
  pathname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BinaryTypeRequest::mutable_pathname() {
  set_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    pathname_ = new ::std::string;
  }
  return pathname_;
}
inline ::std::string* BinaryTypeRequest::release_pathname() {
  clear_has_pathname();
  if (pathname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pathname_;
    pathname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BinaryTypeResponse

// optional bool failure = 1;
inline bool BinaryTypeResponse::has_failure() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinaryTypeResponse::set_has_failure() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BinaryTypeResponse::clear_has_failure() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BinaryTypeResponse::clear_failure() {
  failure_ = false;
  clear_has_failure();
}
inline bool BinaryTypeResponse::failure() const {
  return failure_;
}
inline void BinaryTypeResponse::set_failure(bool value) {
  set_has_failure();
  failure_ = value;
}

// optional .contester.proto.BinaryTypeResponse.Win32BinaryType result = 2;
inline bool BinaryTypeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BinaryTypeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BinaryTypeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BinaryTypeResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::contester::proto::BinaryTypeResponse_Win32BinaryType BinaryTypeResponse::result() const {
  return static_cast< ::contester::proto::BinaryTypeResponse_Win32BinaryType >(result_);
}
inline void BinaryTypeResponse::set_result(::contester::proto::BinaryTypeResponse_Win32BinaryType value) {
  GOOGLE_DCHECK(::contester::proto::BinaryTypeResponse_Win32BinaryType_IsValid(value));
  set_has_result();
  result_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace contester

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::contester::proto::BinaryTypeResponse_Win32BinaryType>() {
  return ::contester::proto::BinaryTypeResponse_Win32BinaryType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_contester_2fproto_2fLocalProto_2eproto__INCLUDED
