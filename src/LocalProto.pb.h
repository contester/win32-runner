// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LocalProto.proto

#ifndef PROTOBUF_LocalProto_2eproto__INCLUDED
#define PROTOBUF_LocalProto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "BlobProto.pb.h"
#include "ExecutionProto.pb.h"
// @@protoc_insertion_point(includes)

namespace contester {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_LocalProto_2eproto();
void protobuf_AssignDesc_LocalProto_2eproto();
void protobuf_ShutdownFile_LocalProto_2eproto();

class LocalEnvironment;
class LocalEnvironment_Variable;
class LoginInformation;
class LocalExecutionParameters;
class LocalExecutionResult;
class LocalExecution;

// ===================================================================

class LocalEnvironment_Variable : public ::google::protobuf::Message {
 public:
  LocalEnvironment_Variable();
  virtual ~LocalEnvironment_Variable();
  
  LocalEnvironment_Variable(const LocalEnvironment_Variable& from);
  
  inline LocalEnvironment_Variable& operator=(const LocalEnvironment_Variable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalEnvironment_Variable& default_instance();
  
  void Swap(LocalEnvironment_Variable* other);
  
  // implements Message ----------------------------------------------
  
  LocalEnvironment_Variable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalEnvironment_Variable& from);
  void MergeFrom(const LocalEnvironment_Variable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // optional bool expand = 3;
  inline bool has_expand() const;
  inline void clear_expand();
  static const int kExpandFieldNumber = 3;
  inline bool expand() const;
  inline void set_expand(bool value);
  
  // @@protoc_insertion_point(class_scope:contester.proto.LocalEnvironment.Variable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  bool expand_;
  friend void  protobuf_AddDesc_LocalProto_2eproto();
  friend void protobuf_AssignDesc_LocalProto_2eproto();
  friend void protobuf_ShutdownFile_LocalProto_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LocalEnvironment_Variable* default_instance_;
};
// -------------------------------------------------------------------

class LocalEnvironment : public ::google::protobuf::Message {
 public:
  LocalEnvironment();
  virtual ~LocalEnvironment();
  
  LocalEnvironment(const LocalEnvironment& from);
  
  inline LocalEnvironment& operator=(const LocalEnvironment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalEnvironment& default_instance();
  
  void Swap(LocalEnvironment* other);
  
  // implements Message ----------------------------------------------
  
  LocalEnvironment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalEnvironment& from);
  void MergeFrom(const LocalEnvironment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LocalEnvironment_Variable Variable;
  
  // accessors -------------------------------------------------------
  
  // optional bool empty = 1;
  inline bool has_empty() const;
  inline void clear_empty();
  static const int kEmptyFieldNumber = 1;
  inline bool empty() const;
  inline void set_empty(bool value);
  
  // repeated .contester.proto.LocalEnvironment.Variable variable = 2;
  inline int variable_size() const;
  inline void clear_variable();
  static const int kVariableFieldNumber = 2;
  inline const ::contester::proto::LocalEnvironment_Variable& variable(int index) const;
  inline ::contester::proto::LocalEnvironment_Variable* mutable_variable(int index);
  inline ::contester::proto::LocalEnvironment_Variable* add_variable();
  inline const ::google::protobuf::RepeatedPtrField< ::contester::proto::LocalEnvironment_Variable >&
      variable() const;
  inline ::google::protobuf::RepeatedPtrField< ::contester::proto::LocalEnvironment_Variable >*
      mutable_variable();
  
  // @@protoc_insertion_point(class_scope:contester.proto.LocalEnvironment)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool empty_;
  ::google::protobuf::RepeatedPtrField< ::contester::proto::LocalEnvironment_Variable > variable_;
  friend void  protobuf_AddDesc_LocalProto_2eproto();
  friend void protobuf_AssignDesc_LocalProto_2eproto();
  friend void protobuf_ShutdownFile_LocalProto_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LocalEnvironment* default_instance_;
};
// -------------------------------------------------------------------

class LoginInformation : public ::google::protobuf::Message {
 public:
  LoginInformation();
  virtual ~LoginInformation();
  
  LoginInformation(const LoginInformation& from);
  
  inline LoginInformation& operator=(const LoginInformation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginInformation& default_instance();
  
  void Swap(LoginInformation* other);
  
  // implements Message ----------------------------------------------
  
  LoginInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginInformation& from);
  void MergeFrom(const LoginInformation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  
  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  
  // optional string domain = 3;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 3;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  
  // @@protoc_insertion_point(class_scope:contester.proto.LoginInformation)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* username_;
  static const ::std::string _default_username_;
  ::std::string* password_;
  static const ::std::string _default_password_;
  ::std::string* domain_;
  static const ::std::string _default_domain_;
  friend void  protobuf_AddDesc_LocalProto_2eproto();
  friend void protobuf_AssignDesc_LocalProto_2eproto();
  friend void protobuf_ShutdownFile_LocalProto_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LoginInformation* default_instance_;
};
// -------------------------------------------------------------------

class LocalExecutionParameters : public ::google::protobuf::Message {
 public:
  LocalExecutionParameters();
  virtual ~LocalExecutionParameters();
  
  LocalExecutionParameters(const LocalExecutionParameters& from);
  
  inline LocalExecutionParameters& operator=(const LocalExecutionParameters& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalExecutionParameters& default_instance();
  
  void Swap(LocalExecutionParameters* other);
  
  // implements Message ----------------------------------------------
  
  LocalExecutionParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalExecutionParameters& from);
  void MergeFrom(const LocalExecutionParameters& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string application_name = 1;
  inline bool has_application_name() const;
  inline void clear_application_name();
  static const int kApplicationNameFieldNumber = 1;
  inline const ::std::string& application_name() const;
  inline void set_application_name(const ::std::string& value);
  inline void set_application_name(const char* value);
  inline void set_application_name(const char* value, size_t size);
  inline ::std::string* mutable_application_name();
  
  // optional string command_line = 2;
  inline bool has_command_line() const;
  inline void clear_command_line();
  static const int kCommandLineFieldNumber = 2;
  inline const ::std::string& command_line() const;
  inline void set_command_line(const ::std::string& value);
  inline void set_command_line(const char* value);
  inline void set_command_line(const char* value, size_t size);
  inline ::std::string* mutable_command_line();
  
  // optional string current_directory = 3;
  inline bool has_current_directory() const;
  inline void clear_current_directory();
  static const int kCurrentDirectoryFieldNumber = 3;
  inline const ::std::string& current_directory() const;
  inline void set_current_directory(const ::std::string& value);
  inline void set_current_directory(const char* value);
  inline void set_current_directory(const char* value, size_t size);
  inline ::std::string* mutable_current_directory();
  
  // optional float time_limit = 4;
  inline bool has_time_limit() const;
  inline void clear_time_limit();
  static const int kTimeLimitFieldNumber = 4;
  inline float time_limit() const;
  inline void set_time_limit(float value);
  
  // optional uint64 memory_limit = 5;
  inline bool has_memory_limit() const;
  inline void clear_memory_limit();
  static const int kMemoryLimitFieldNumber = 5;
  inline ::google::protobuf::uint64 memory_limit() const;
  inline void set_memory_limit(::google::protobuf::uint64 value);
  
  // optional bool check_idleness = 6;
  inline bool has_check_idleness() const;
  inline void clear_check_idleness();
  static const int kCheckIdlenessFieldNumber = 6;
  inline bool check_idleness() const;
  inline void set_check_idleness(bool value);
  
  // optional .contester.proto.LocalEnvironment environment = 7;
  inline bool has_environment() const;
  inline void clear_environment();
  static const int kEnvironmentFieldNumber = 7;
  inline const ::contester::proto::LocalEnvironment& environment() const;
  inline ::contester::proto::LocalEnvironment* mutable_environment();
  
  // optional bool restrict_ui = 8;
  inline bool has_restrict_ui() const;
  inline void clear_restrict_ui();
  static const int kRestrictUiFieldNumber = 8;
  inline bool restrict_ui() const;
  inline void set_restrict_ui(bool value);
  
  // optional bool no_job = 9;
  inline bool has_no_job() const;
  inline void clear_no_job();
  static const int kNoJobFieldNumber = 9;
  inline bool no_job() const;
  inline void set_no_job(bool value);
  
  // optional uint32 process_limit = 10;
  inline bool has_process_limit() const;
  inline void clear_process_limit();
  static const int kProcessLimitFieldNumber = 10;
  inline ::google::protobuf::uint32 process_limit() const;
  inline void set_process_limit(::google::protobuf::uint32 value);
  
  // optional float time_limit_hard = 15;
  inline bool has_time_limit_hard() const;
  inline void clear_time_limit_hard();
  static const int kTimeLimitHardFieldNumber = 15;
  inline float time_limit_hard() const;
  inline void set_time_limit_hard(float value);
  
  // optional .contester.proto.LoginInformation login_information = 11;
  inline bool has_login_information() const;
  inline void clear_login_information();
  static const int kLoginInformationFieldNumber = 11;
  inline const ::contester::proto::LoginInformation& login_information() const;
  inline ::contester::proto::LoginInformation* mutable_login_information();
  
  // optional .contester.proto.RedirectParameters std_in = 12;
  inline bool has_std_in() const;
  inline void clear_std_in();
  static const int kStdInFieldNumber = 12;
  inline const ::contester::proto::RedirectParameters& std_in() const;
  inline ::contester::proto::RedirectParameters* mutable_std_in();
  
  // optional .contester.proto.RedirectParameters std_out = 13;
  inline bool has_std_out() const;
  inline void clear_std_out();
  static const int kStdOutFieldNumber = 13;
  inline const ::contester::proto::RedirectParameters& std_out() const;
  inline ::contester::proto::RedirectParameters* mutable_std_out();
  
  // optional .contester.proto.RedirectParameters std_err = 14;
  inline bool has_std_err() const;
  inline void clear_std_err();
  static const int kStdErrFieldNumber = 14;
  inline const ::contester::proto::RedirectParameters& std_err() const;
  inline ::contester::proto::RedirectParameters* mutable_std_err();
  
  // @@protoc_insertion_point(class_scope:contester.proto.LocalExecutionParameters)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* application_name_;
  static const ::std::string _default_application_name_;
  ::std::string* command_line_;
  static const ::std::string _default_command_line_;
  ::std::string* current_directory_;
  static const ::std::string _default_current_directory_;
  float time_limit_;
  ::google::protobuf::uint64 memory_limit_;
  bool check_idleness_;
  ::contester::proto::LocalEnvironment* environment_;
  bool restrict_ui_;
  bool no_job_;
  ::google::protobuf::uint32 process_limit_;
  float time_limit_hard_;
  ::contester::proto::LoginInformation* login_information_;
  ::contester::proto::RedirectParameters* std_in_;
  ::contester::proto::RedirectParameters* std_out_;
  ::contester::proto::RedirectParameters* std_err_;
  friend void  protobuf_AddDesc_LocalProto_2eproto();
  friend void protobuf_AssignDesc_LocalProto_2eproto();
  friend void protobuf_ShutdownFile_LocalProto_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LocalExecutionParameters* default_instance_;
};
// -------------------------------------------------------------------

class LocalExecutionResult : public ::google::protobuf::Message {
 public:
  LocalExecutionResult();
  virtual ~LocalExecutionResult();
  
  LocalExecutionResult(const LocalExecutionResult& from);
  
  inline LocalExecutionResult& operator=(const LocalExecutionResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalExecutionResult& default_instance();
  
  void Swap(LocalExecutionResult* other);
  
  // implements Message ----------------------------------------------
  
  LocalExecutionResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalExecutionResult& from);
  void MergeFrom(const LocalExecutionResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .contester.proto.ExecutionResultFlags flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline const ::contester::proto::ExecutionResultFlags& flags() const;
  inline ::contester::proto::ExecutionResultFlags* mutable_flags();
  
  // optional .contester.proto.ExecutionResultTime time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::contester::proto::ExecutionResultTime& time() const;
  inline ::contester::proto::ExecutionResultTime* mutable_time();
  
  // optional uint64 memory = 3;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 3;
  inline ::google::protobuf::uint64 memory() const;
  inline void set_memory(::google::protobuf::uint64 value);
  
  // optional uint32 return_code = 4;
  inline bool has_return_code() const;
  inline void clear_return_code();
  static const int kReturnCodeFieldNumber = 4;
  inline ::google::protobuf::uint32 return_code() const;
  inline void set_return_code(::google::protobuf::uint32 value);
  
  // optional .contester.proto.Blob std_out = 5;
  inline bool has_std_out() const;
  inline void clear_std_out();
  static const int kStdOutFieldNumber = 5;
  inline const ::contester::proto::Blob& std_out() const;
  inline ::contester::proto::Blob* mutable_std_out();
  
  // optional .contester.proto.Blob std_err = 6;
  inline bool has_std_err() const;
  inline void clear_std_err();
  static const int kStdErrFieldNumber = 6;
  inline const ::contester::proto::Blob& std_err() const;
  inline ::contester::proto::Blob* mutable_std_err();
  
  // optional uint64 total_processes = 7;
  inline bool has_total_processes() const;
  inline void clear_total_processes();
  static const int kTotalProcessesFieldNumber = 7;
  inline ::google::protobuf::uint64 total_processes() const;
  inline void set_total_processes(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:contester.proto.LocalExecutionResult)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::contester::proto::ExecutionResultFlags* flags_;
  ::contester::proto::ExecutionResultTime* time_;
  ::google::protobuf::uint64 memory_;
  ::google::protobuf::uint32 return_code_;
  ::contester::proto::Blob* std_out_;
  ::contester::proto::Blob* std_err_;
  ::google::protobuf::uint64 total_processes_;
  friend void  protobuf_AddDesc_LocalProto_2eproto();
  friend void protobuf_AssignDesc_LocalProto_2eproto();
  friend void protobuf_ShutdownFile_LocalProto_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LocalExecutionResult* default_instance_;
};
// -------------------------------------------------------------------

class LocalExecution : public ::google::protobuf::Message {
 public:
  LocalExecution();
  virtual ~LocalExecution();
  
  LocalExecution(const LocalExecution& from);
  
  inline LocalExecution& operator=(const LocalExecution& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalExecution& default_instance();
  
  void Swap(LocalExecution* other);
  
  // implements Message ----------------------------------------------
  
  LocalExecution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalExecution& from);
  void MergeFrom(const LocalExecution& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .contester.proto.LocalExecutionParameters parameters = 1;
  inline bool has_parameters() const;
  inline void clear_parameters();
  static const int kParametersFieldNumber = 1;
  inline const ::contester::proto::LocalExecutionParameters& parameters() const;
  inline ::contester::proto::LocalExecutionParameters* mutable_parameters();
  
  // optional .contester.proto.LocalExecutionResult result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::contester::proto::LocalExecutionResult& result() const;
  inline ::contester::proto::LocalExecutionResult* mutable_result();
  
  // @@protoc_insertion_point(class_scope:contester.proto.LocalExecution)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::contester::proto::LocalExecutionParameters* parameters_;
  ::contester::proto::LocalExecutionResult* result_;
  friend void  protobuf_AddDesc_LocalProto_2eproto();
  friend void protobuf_AssignDesc_LocalProto_2eproto();
  friend void protobuf_ShutdownFile_LocalProto_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LocalExecution* default_instance_;
};
// ===================================================================


// ===================================================================

// LocalEnvironment_Variable

// required string name = 1;
inline bool LocalEnvironment_Variable::has_name() const {
  return _has_bit(0);
}
inline void LocalEnvironment_Variable::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& LocalEnvironment_Variable::name() const {
  return *name_;
}
inline void LocalEnvironment_Variable::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LocalEnvironment_Variable::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LocalEnvironment_Variable::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalEnvironment_Variable::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string value = 2;
inline bool LocalEnvironment_Variable::has_value() const {
  return _has_bit(1);
}
inline void LocalEnvironment_Variable::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LocalEnvironment_Variable::value() const {
  return *value_;
}
inline void LocalEnvironment_Variable::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void LocalEnvironment_Variable::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void LocalEnvironment_Variable::set_value(const char* value, size_t size) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalEnvironment_Variable::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// optional bool expand = 3;
inline bool LocalEnvironment_Variable::has_expand() const {
  return _has_bit(2);
}
inline void LocalEnvironment_Variable::clear_expand() {
  expand_ = false;
  _clear_bit(2);
}
inline bool LocalEnvironment_Variable::expand() const {
  return expand_;
}
inline void LocalEnvironment_Variable::set_expand(bool value) {
  _set_bit(2);
  expand_ = value;
}

// -------------------------------------------------------------------

// LocalEnvironment

// optional bool empty = 1;
inline bool LocalEnvironment::has_empty() const {
  return _has_bit(0);
}
inline void LocalEnvironment::clear_empty() {
  empty_ = false;
  _clear_bit(0);
}
inline bool LocalEnvironment::empty() const {
  return empty_;
}
inline void LocalEnvironment::set_empty(bool value) {
  _set_bit(0);
  empty_ = value;
}

// repeated .contester.proto.LocalEnvironment.Variable variable = 2;
inline int LocalEnvironment::variable_size() const {
  return variable_.size();
}
inline void LocalEnvironment::clear_variable() {
  variable_.Clear();
}
inline const ::contester::proto::LocalEnvironment_Variable& LocalEnvironment::variable(int index) const {
  return variable_.Get(index);
}
inline ::contester::proto::LocalEnvironment_Variable* LocalEnvironment::mutable_variable(int index) {
  return variable_.Mutable(index);
}
inline ::contester::proto::LocalEnvironment_Variable* LocalEnvironment::add_variable() {
  return variable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::contester::proto::LocalEnvironment_Variable >&
LocalEnvironment::variable() const {
  return variable_;
}
inline ::google::protobuf::RepeatedPtrField< ::contester::proto::LocalEnvironment_Variable >*
LocalEnvironment::mutable_variable() {
  return &variable_;
}

// -------------------------------------------------------------------

// LoginInformation

// required string username = 1;
inline bool LoginInformation::has_username() const {
  return _has_bit(0);
}
inline void LoginInformation::clear_username() {
  if (username_ != &_default_username_) {
    username_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& LoginInformation::username() const {
  return *username_;
}
inline void LoginInformation::set_username(const ::std::string& value) {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginInformation::set_username(const char* value) {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginInformation::set_username(const char* value, size_t size) {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInformation::mutable_username() {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  return username_;
}

// required string password = 2;
inline bool LoginInformation::has_password() const {
  return _has_bit(1);
}
inline void LoginInformation::clear_password() {
  if (password_ != &_default_password_) {
    password_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LoginInformation::password() const {
  return *password_;
}
inline void LoginInformation::set_password(const ::std::string& value) {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginInformation::set_password(const char* value) {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginInformation::set_password(const char* value, size_t size) {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInformation::mutable_password() {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  return password_;
}

// optional string domain = 3;
inline bool LoginInformation::has_domain() const {
  return _has_bit(2);
}
inline void LoginInformation::clear_domain() {
  if (domain_ != &_default_domain_) {
    domain_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& LoginInformation::domain() const {
  return *domain_;
}
inline void LoginInformation::set_domain(const ::std::string& value) {
  _set_bit(2);
  if (domain_ == &_default_domain_) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void LoginInformation::set_domain(const char* value) {
  _set_bit(2);
  if (domain_ == &_default_domain_) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void LoginInformation::set_domain(const char* value, size_t size) {
  _set_bit(2);
  if (domain_ == &_default_domain_) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInformation::mutable_domain() {
  _set_bit(2);
  if (domain_ == &_default_domain_) {
    domain_ = new ::std::string;
  }
  return domain_;
}

// -------------------------------------------------------------------

// LocalExecutionParameters

// optional string application_name = 1;
inline bool LocalExecutionParameters::has_application_name() const {
  return _has_bit(0);
}
inline void LocalExecutionParameters::clear_application_name() {
  if (application_name_ != &_default_application_name_) {
    application_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& LocalExecutionParameters::application_name() const {
  return *application_name_;
}
inline void LocalExecutionParameters::set_application_name(const ::std::string& value) {
  _set_bit(0);
  if (application_name_ == &_default_application_name_) {
    application_name_ = new ::std::string;
  }
  application_name_->assign(value);
}
inline void LocalExecutionParameters::set_application_name(const char* value) {
  _set_bit(0);
  if (application_name_ == &_default_application_name_) {
    application_name_ = new ::std::string;
  }
  application_name_->assign(value);
}
inline void LocalExecutionParameters::set_application_name(const char* value, size_t size) {
  _set_bit(0);
  if (application_name_ == &_default_application_name_) {
    application_name_ = new ::std::string;
  }
  application_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalExecutionParameters::mutable_application_name() {
  _set_bit(0);
  if (application_name_ == &_default_application_name_) {
    application_name_ = new ::std::string;
  }
  return application_name_;
}

// optional string command_line = 2;
inline bool LocalExecutionParameters::has_command_line() const {
  return _has_bit(1);
}
inline void LocalExecutionParameters::clear_command_line() {
  if (command_line_ != &_default_command_line_) {
    command_line_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LocalExecutionParameters::command_line() const {
  return *command_line_;
}
inline void LocalExecutionParameters::set_command_line(const ::std::string& value) {
  _set_bit(1);
  if (command_line_ == &_default_command_line_) {
    command_line_ = new ::std::string;
  }
  command_line_->assign(value);
}
inline void LocalExecutionParameters::set_command_line(const char* value) {
  _set_bit(1);
  if (command_line_ == &_default_command_line_) {
    command_line_ = new ::std::string;
  }
  command_line_->assign(value);
}
inline void LocalExecutionParameters::set_command_line(const char* value, size_t size) {
  _set_bit(1);
  if (command_line_ == &_default_command_line_) {
    command_line_ = new ::std::string;
  }
  command_line_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalExecutionParameters::mutable_command_line() {
  _set_bit(1);
  if (command_line_ == &_default_command_line_) {
    command_line_ = new ::std::string;
  }
  return command_line_;
}

// optional string current_directory = 3;
inline bool LocalExecutionParameters::has_current_directory() const {
  return _has_bit(2);
}
inline void LocalExecutionParameters::clear_current_directory() {
  if (current_directory_ != &_default_current_directory_) {
    current_directory_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& LocalExecutionParameters::current_directory() const {
  return *current_directory_;
}
inline void LocalExecutionParameters::set_current_directory(const ::std::string& value) {
  _set_bit(2);
  if (current_directory_ == &_default_current_directory_) {
    current_directory_ = new ::std::string;
  }
  current_directory_->assign(value);
}
inline void LocalExecutionParameters::set_current_directory(const char* value) {
  _set_bit(2);
  if (current_directory_ == &_default_current_directory_) {
    current_directory_ = new ::std::string;
  }
  current_directory_->assign(value);
}
inline void LocalExecutionParameters::set_current_directory(const char* value, size_t size) {
  _set_bit(2);
  if (current_directory_ == &_default_current_directory_) {
    current_directory_ = new ::std::string;
  }
  current_directory_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalExecutionParameters::mutable_current_directory() {
  _set_bit(2);
  if (current_directory_ == &_default_current_directory_) {
    current_directory_ = new ::std::string;
  }
  return current_directory_;
}

// optional float time_limit = 4;
inline bool LocalExecutionParameters::has_time_limit() const {
  return _has_bit(3);
}
inline void LocalExecutionParameters::clear_time_limit() {
  time_limit_ = 0;
  _clear_bit(3);
}
inline float LocalExecutionParameters::time_limit() const {
  return time_limit_;
}
inline void LocalExecutionParameters::set_time_limit(float value) {
  _set_bit(3);
  time_limit_ = value;
}

// optional uint64 memory_limit = 5;
inline bool LocalExecutionParameters::has_memory_limit() const {
  return _has_bit(4);
}
inline void LocalExecutionParameters::clear_memory_limit() {
  memory_limit_ = GOOGLE_ULONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::uint64 LocalExecutionParameters::memory_limit() const {
  return memory_limit_;
}
inline void LocalExecutionParameters::set_memory_limit(::google::protobuf::uint64 value) {
  _set_bit(4);
  memory_limit_ = value;
}

// optional bool check_idleness = 6;
inline bool LocalExecutionParameters::has_check_idleness() const {
  return _has_bit(5);
}
inline void LocalExecutionParameters::clear_check_idleness() {
  check_idleness_ = false;
  _clear_bit(5);
}
inline bool LocalExecutionParameters::check_idleness() const {
  return check_idleness_;
}
inline void LocalExecutionParameters::set_check_idleness(bool value) {
  _set_bit(5);
  check_idleness_ = value;
}

// optional .contester.proto.LocalEnvironment environment = 7;
inline bool LocalExecutionParameters::has_environment() const {
  return _has_bit(6);
}
inline void LocalExecutionParameters::clear_environment() {
  if (environment_ != NULL) environment_->::contester::proto::LocalEnvironment::Clear();
  _clear_bit(6);
}
inline const ::contester::proto::LocalEnvironment& LocalExecutionParameters::environment() const {
  return environment_ != NULL ? *environment_ : *default_instance_->environment_;
}
inline ::contester::proto::LocalEnvironment* LocalExecutionParameters::mutable_environment() {
  _set_bit(6);
  if (environment_ == NULL) environment_ = new ::contester::proto::LocalEnvironment;
  return environment_;
}

// optional bool restrict_ui = 8;
inline bool LocalExecutionParameters::has_restrict_ui() const {
  return _has_bit(7);
}
inline void LocalExecutionParameters::clear_restrict_ui() {
  restrict_ui_ = false;
  _clear_bit(7);
}
inline bool LocalExecutionParameters::restrict_ui() const {
  return restrict_ui_;
}
inline void LocalExecutionParameters::set_restrict_ui(bool value) {
  _set_bit(7);
  restrict_ui_ = value;
}

// optional bool no_job = 9;
inline bool LocalExecutionParameters::has_no_job() const {
  return _has_bit(8);
}
inline void LocalExecutionParameters::clear_no_job() {
  no_job_ = false;
  _clear_bit(8);
}
inline bool LocalExecutionParameters::no_job() const {
  return no_job_;
}
inline void LocalExecutionParameters::set_no_job(bool value) {
  _set_bit(8);
  no_job_ = value;
}

// optional uint32 process_limit = 10;
inline bool LocalExecutionParameters::has_process_limit() const {
  return _has_bit(9);
}
inline void LocalExecutionParameters::clear_process_limit() {
  process_limit_ = 0u;
  _clear_bit(9);
}
inline ::google::protobuf::uint32 LocalExecutionParameters::process_limit() const {
  return process_limit_;
}
inline void LocalExecutionParameters::set_process_limit(::google::protobuf::uint32 value) {
  _set_bit(9);
  process_limit_ = value;
}

// optional float time_limit_hard = 15;
inline bool LocalExecutionParameters::has_time_limit_hard() const {
  return _has_bit(10);
}
inline void LocalExecutionParameters::clear_time_limit_hard() {
  time_limit_hard_ = 0;
  _clear_bit(10);
}
inline float LocalExecutionParameters::time_limit_hard() const {
  return time_limit_hard_;
}
inline void LocalExecutionParameters::set_time_limit_hard(float value) {
  _set_bit(10);
  time_limit_hard_ = value;
}

// optional .contester.proto.LoginInformation login_information = 11;
inline bool LocalExecutionParameters::has_login_information() const {
  return _has_bit(11);
}
inline void LocalExecutionParameters::clear_login_information() {
  if (login_information_ != NULL) login_information_->::contester::proto::LoginInformation::Clear();
  _clear_bit(11);
}
inline const ::contester::proto::LoginInformation& LocalExecutionParameters::login_information() const {
  return login_information_ != NULL ? *login_information_ : *default_instance_->login_information_;
}
inline ::contester::proto::LoginInformation* LocalExecutionParameters::mutable_login_information() {
  _set_bit(11);
  if (login_information_ == NULL) login_information_ = new ::contester::proto::LoginInformation;
  return login_information_;
}

// optional .contester.proto.RedirectParameters std_in = 12;
inline bool LocalExecutionParameters::has_std_in() const {
  return _has_bit(12);
}
inline void LocalExecutionParameters::clear_std_in() {
  if (std_in_ != NULL) std_in_->::contester::proto::RedirectParameters::Clear();
  _clear_bit(12);
}
inline const ::contester::proto::RedirectParameters& LocalExecutionParameters::std_in() const {
  return std_in_ != NULL ? *std_in_ : *default_instance_->std_in_;
}
inline ::contester::proto::RedirectParameters* LocalExecutionParameters::mutable_std_in() {
  _set_bit(12);
  if (std_in_ == NULL) std_in_ = new ::contester::proto::RedirectParameters;
  return std_in_;
}

// optional .contester.proto.RedirectParameters std_out = 13;
inline bool LocalExecutionParameters::has_std_out() const {
  return _has_bit(13);
}
inline void LocalExecutionParameters::clear_std_out() {
  if (std_out_ != NULL) std_out_->::contester::proto::RedirectParameters::Clear();
  _clear_bit(13);
}
inline const ::contester::proto::RedirectParameters& LocalExecutionParameters::std_out() const {
  return std_out_ != NULL ? *std_out_ : *default_instance_->std_out_;
}
inline ::contester::proto::RedirectParameters* LocalExecutionParameters::mutable_std_out() {
  _set_bit(13);
  if (std_out_ == NULL) std_out_ = new ::contester::proto::RedirectParameters;
  return std_out_;
}

// optional .contester.proto.RedirectParameters std_err = 14;
inline bool LocalExecutionParameters::has_std_err() const {
  return _has_bit(14);
}
inline void LocalExecutionParameters::clear_std_err() {
  if (std_err_ != NULL) std_err_->::contester::proto::RedirectParameters::Clear();
  _clear_bit(14);
}
inline const ::contester::proto::RedirectParameters& LocalExecutionParameters::std_err() const {
  return std_err_ != NULL ? *std_err_ : *default_instance_->std_err_;
}
inline ::contester::proto::RedirectParameters* LocalExecutionParameters::mutable_std_err() {
  _set_bit(14);
  if (std_err_ == NULL) std_err_ = new ::contester::proto::RedirectParameters;
  return std_err_;
}

// -------------------------------------------------------------------

// LocalExecutionResult

// optional .contester.proto.ExecutionResultFlags flags = 1;
inline bool LocalExecutionResult::has_flags() const {
  return _has_bit(0);
}
inline void LocalExecutionResult::clear_flags() {
  if (flags_ != NULL) flags_->::contester::proto::ExecutionResultFlags::Clear();
  _clear_bit(0);
}
inline const ::contester::proto::ExecutionResultFlags& LocalExecutionResult::flags() const {
  return flags_ != NULL ? *flags_ : *default_instance_->flags_;
}
inline ::contester::proto::ExecutionResultFlags* LocalExecutionResult::mutable_flags() {
  _set_bit(0);
  if (flags_ == NULL) flags_ = new ::contester::proto::ExecutionResultFlags;
  return flags_;
}

// optional .contester.proto.ExecutionResultTime time = 2;
inline bool LocalExecutionResult::has_time() const {
  return _has_bit(1);
}
inline void LocalExecutionResult::clear_time() {
  if (time_ != NULL) time_->::contester::proto::ExecutionResultTime::Clear();
  _clear_bit(1);
}
inline const ::contester::proto::ExecutionResultTime& LocalExecutionResult::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::contester::proto::ExecutionResultTime* LocalExecutionResult::mutable_time() {
  _set_bit(1);
  if (time_ == NULL) time_ = new ::contester::proto::ExecutionResultTime;
  return time_;
}

// optional uint64 memory = 3;
inline bool LocalExecutionResult::has_memory() const {
  return _has_bit(2);
}
inline void LocalExecutionResult::clear_memory() {
  memory_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 LocalExecutionResult::memory() const {
  return memory_;
}
inline void LocalExecutionResult::set_memory(::google::protobuf::uint64 value) {
  _set_bit(2);
  memory_ = value;
}

// optional uint32 return_code = 4;
inline bool LocalExecutionResult::has_return_code() const {
  return _has_bit(3);
}
inline void LocalExecutionResult::clear_return_code() {
  return_code_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 LocalExecutionResult::return_code() const {
  return return_code_;
}
inline void LocalExecutionResult::set_return_code(::google::protobuf::uint32 value) {
  _set_bit(3);
  return_code_ = value;
}

// optional .contester.proto.Blob std_out = 5;
inline bool LocalExecutionResult::has_std_out() const {
  return _has_bit(4);
}
inline void LocalExecutionResult::clear_std_out() {
  if (std_out_ != NULL) std_out_->::contester::proto::Blob::Clear();
  _clear_bit(4);
}
inline const ::contester::proto::Blob& LocalExecutionResult::std_out() const {
  return std_out_ != NULL ? *std_out_ : *default_instance_->std_out_;
}
inline ::contester::proto::Blob* LocalExecutionResult::mutable_std_out() {
  _set_bit(4);
  if (std_out_ == NULL) std_out_ = new ::contester::proto::Blob;
  return std_out_;
}

// optional .contester.proto.Blob std_err = 6;
inline bool LocalExecutionResult::has_std_err() const {
  return _has_bit(5);
}
inline void LocalExecutionResult::clear_std_err() {
  if (std_err_ != NULL) std_err_->::contester::proto::Blob::Clear();
  _clear_bit(5);
}
inline const ::contester::proto::Blob& LocalExecutionResult::std_err() const {
  return std_err_ != NULL ? *std_err_ : *default_instance_->std_err_;
}
inline ::contester::proto::Blob* LocalExecutionResult::mutable_std_err() {
  _set_bit(5);
  if (std_err_ == NULL) std_err_ = new ::contester::proto::Blob;
  return std_err_;
}

// optional uint64 total_processes = 7;
inline bool LocalExecutionResult::has_total_processes() const {
  return _has_bit(6);
}
inline void LocalExecutionResult::clear_total_processes() {
  total_processes_ = GOOGLE_ULONGLONG(0);
  _clear_bit(6);
}
inline ::google::protobuf::uint64 LocalExecutionResult::total_processes() const {
  return total_processes_;
}
inline void LocalExecutionResult::set_total_processes(::google::protobuf::uint64 value) {
  _set_bit(6);
  total_processes_ = value;
}

// -------------------------------------------------------------------

// LocalExecution

// required .contester.proto.LocalExecutionParameters parameters = 1;
inline bool LocalExecution::has_parameters() const {
  return _has_bit(0);
}
inline void LocalExecution::clear_parameters() {
  if (parameters_ != NULL) parameters_->::contester::proto::LocalExecutionParameters::Clear();
  _clear_bit(0);
}
inline const ::contester::proto::LocalExecutionParameters& LocalExecution::parameters() const {
  return parameters_ != NULL ? *parameters_ : *default_instance_->parameters_;
}
inline ::contester::proto::LocalExecutionParameters* LocalExecution::mutable_parameters() {
  _set_bit(0);
  if (parameters_ == NULL) parameters_ = new ::contester::proto::LocalExecutionParameters;
  return parameters_;
}

// optional .contester.proto.LocalExecutionResult result = 2;
inline bool LocalExecution::has_result() const {
  return _has_bit(1);
}
inline void LocalExecution::clear_result() {
  if (result_ != NULL) result_->::contester::proto::LocalExecutionResult::Clear();
  _clear_bit(1);
}
inline const ::contester::proto::LocalExecutionResult& LocalExecution::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::contester::proto::LocalExecutionResult* LocalExecution::mutable_result() {
  _set_bit(1);
  if (result_ == NULL) result_ = new ::contester::proto::LocalExecutionResult;
  return result_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace contester

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_LocalProto_2eproto__INCLUDED
